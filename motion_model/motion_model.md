# motion_model
車両の運動モデルに基づいて位置と姿勢を計算するプログラムをまとめています。  

## 目次
* [運動モデルとは](#運動モデルとは)
* [直線運動モデル](#直線運動モデル)
* [円運動モデル](#円運動モデル)
* [四輪モデル](#四輪モデル)
* [二輪モデル](#二輪モデル)

## 運動モデルとは
制御対象である車両の動きを理論的に定式化したものです。車両自身の移動速度や姿勢角速度、ステアリング舵角に応じて、次の時刻における位置と姿勢がどうなるかを予測したり、仮想環境での制御シミュレーションを実施したりするのに利用されます。  
こういった運動モデルを扱うためには、車両の運動学(ビークルダイナミクス)の知識が必要になるので、ここではその基礎を学び、その計算式をPythonで実装出来るようになることを目指します。 

## 直線運動モデル
### 理論式
まず一番シンプルな運動モデルとして、直線運動モデルというものがあります。これは、ある時刻$t$から次の時刻$t+1$の間を移動する際の車両の動きを直線で近似したものです。そして、このモデルによって時刻$t+1$における車両の位置と方位を計算する式は、$\\
x_{t+1} = x_t + v_t cos\theta_t dt \\
y_{t+1} = y_t + v_t sin\theta_t dt \\
\theta_{t+1} = \theta_t + \omega_t dt \\
$のようになります。この式における$v_t$は時刻$t$の時の車両の速度、$\omega_t$は同じく時刻$t$の時の車両の方位角速度であり、これらの情報は車両の車速センサーやジャイロセンサーから取得できるとします。速度に刻み時間をかけることで移動量が求まるので、上の式に含まれるこれらの部分は、時刻$t$から時刻$t+1$までの刻み時間$dt$の間の車両の位置座標$x, y$と方位角$\theta$の変化量ということになります。  
$$
v_t cos\theta_t dt \\
v_t sin\theta_t dt \\
\omega_t dt
$$
その変化量を時刻$t$の時の位置座標$x_t, y_t$と方位角$\theta_t$に足し合わせることで、次の時刻$t+1$の時の位置座標$x_{t+1}, y_{t+1}$と方位角$\theta_{t+1}$が求まるという訳です。  

### Pythonでの実装
こちらのファイルに、[直線運動モデルのPythonコード](/motion_model/linear_motion/linear_motion_model.py)を実装しています。上記の理論式に該当するのはこの部分です。  
```python
def calculate_state(self, x_m, y_m, yaw_deg, speed_ms, yaw_rate_ds):
        """
        速度[m/s]と角速度[deg/s]から車両の位置(x, y)と方位(yaw)を計算する関数
        x_m, y_m, yaw_deg: 1時刻前のx, y座標、方位yaw
        speed_ms: その時刻での速度[m/s]
        yaw_rate_ds: その時刻での角速度[deg/s]
        """

        # 入力
        self.speed_ms = speed_ms
        self.yaw_rate_ds = yaw_rate_ds

        # 直線運動モデルに従って位置と方位を計算
        x = x_m + speed_ms * cos(np.deg2rad(yaw_deg)) * self.interval_sec
        y = y_m + speed_ms * sin(np.deg2rad(yaw_deg)) * self.interval_sec
        yaw = yaw_deg + yaw_rate_ds * self.interval_sec
        
        # 速度と角速度からステアリング角度を計算
        # 速度が0になると0割りになるので注意
        steer_rad = asin(self.wheel_base_m * np.deg2rad(self.yaw_rate_ds)/self.speed_ms)
        
        return x, y, yaw, np.rad2deg(steer_rad)
```
このコードを実行すると、直線運動モデルによる位置と方位を計算するシミュレーションが実行され、このように車両が動くアニメーションが表示されます。  
![](/images/linear_motion_model_simulation.png)  
また、このコードはLinearMotionModelというクラスとしてモジュール化されているので、これをimportすることで他のサンプルプログラムから使うこともできます。使い方については、同ファイルに実装されているmain関数を参照してください。  

### より高精度な直線運動モデル
上記のモデルはシンプルで扱いやすいですが、時刻間の刻み時間$dt$が長くなると、それだけ実際の車両の動きに対してオフセット誤差が生じてしまう場合があります。  
そこで、より高精度に車両の動きをモデル化する工夫として、刻み時間の間の角速度は一定と仮定し、その刻み時間のちょうど真ん中の方位角を使用して、次の時刻の位置座標$x_{t+1}, y_{t+1}$を求めるようにします。それを理論式で表すとこちらのようになります。  
$$
x_{t+1} = x_t + v_t cos(\theta_t + \frac{\omega_t dt}{2}) dt \\
y_{t+1} = y_t + v_t sin(\theta_t + \frac{\omega_t dt}{2}) dt \\
\theta_{t+1} = \theta_t + \omega_t dt
$$  
こうすることで、モデル化によるオフセット誤差はかなり小さくなりますが、刻み時間$dt$が限りなく小さい場合はどちらのモデルを使っても計算結果に大きな差は生じません。[この運動モデルのPythonコードはこちら](/motion_model/linear_motion/accurate_linear_motion_model.py)に置いてあります。このファイルを実行すると、先に説明した運動モデルのコードと同じようなシミュレーションが実行されます。  

### 2つの直線運動モデルの比較
ここまでに紹介した2つの直線運動モデルにより位置座標と方位の計算を比較してみました。  
[こちらのコード](/motion_model/linear_motion/compare_linear_model.py)を実行すると、シンプル版モデル(青)と高精度版モデル(赤)の計算シミュレーションが表示されます。  
まず、刻み時間を50msに設定した場合の比較結果がこちらです。刻み時間が短いので、両者の計算結果に大きな差は生じていないことが分かります。  
![](/images/compare_linear_model_dt50ms.png)  
次に、刻み時間を500msに設定するとこのようになります。両者の理論式を見ると分かるように、位置座標を計算する際の方位角の扱いに違いがあり、その違いは刻み時間が長くなるほど大きくなるので、その様子が見て取れると思います。    
![](/images/compare_linear_model_dt500ms.png)  

## 円運動モデル
直線運動モデルは、刻み時間の間の車両の動きを直線に近似したものですが、現実世界では必ずしも直線とは限らず、旋回して向きを変える動きをする場合も考えられます。車両のそういった旋回の動きを高精度に計算するには、ここから説明する円運動モデルが必要になります。  

### 円運動モデルの導出に必要な物理の知識
下図のようにシンプルなステアリング型ロボットを例に、円運動に関する物理の基礎について触れていきます。ここでは、前輪と後輪の距離(ホイールベース)が$W$となっている機構を持つロボットが、前輪のステアリングを$s$だけ切ることで、旋回半径$R$の大きさの円運動をすることを考えます。  
![](/images/steering_robot.png)  

#### 角速度
円運動において物体が1秒間に回転する角度を角速度といい、回転の速さを表します。  
この図にあるように、$t$秒間に$\theta$[rad]だけ回転したときの角速度$\omega$は、  
$$
\omega = \frac{\theta}{t}
$$
と表せます。  
![](/images/yaw_rate.png)  
また、半径$R$の円周上を円運動する物体が$t$秒間に$\theta$[rad]だけ回転したときに進む距離$l$は、  
$$
l = R \theta
$$
となり、これを時間$t$で割ることで周回する物体の速さ$v$を求めると、  
$$
v = \frac{l}{t} = \frac{R \theta}{t}
$$
となり、これに先程示した$\omega = \frac{\theta}{t}$を代入すると、  
$$
v = R \omega
$$
となります。  

#### 旋回半径と曲率の関係
曲率とは、曲線や曲面の曲がり具合を表す量です。自動運転では、車両が走行する旋回コースの曲がり具合を表すことになります。このとき、旋回半径を$R$[m]、曲率を$k$[1/m]とすると、これらの間には以下のような関係が成り立ちます。  
$$
R = \frac{1}{k}
$$

#### 角速度と曲率、速度の関係
ここまでに示した速度$v=R\omega$と旋回半径$R=\frac{1}{k}$を組み合わせると、  
$$
v = \frac{\omega}{k}
$$
となり、これをさらに変形することで、  
$$
\omega = vk
$$
という角速度と速度の関係式が成り立ちます。この式を利用することで、車両が速度$v$で曲率$k$の旋回コースを走行した際に、車両はどの程度の角速度で方位を変化させるのかを推定することができます。  

#### ステアリング角度と旋回半径、曲率の関係
最初に示したステアリング型ロボットの図より、ステアリング側ロボットと旋回半径との間には以下のような関係が成り立ちます。  
$$
sin(s) = \frac{W}{R}
$$
これに、先程示した旋回半径と曲率の関係である$R=\frac{1}{k}$を組み合わせることで、  
$$
s = sin^{-1}(Wk)
$$
さらに、先程示した角速度と曲率の関係である$\omega=vk$を組み合わせることで、  
$$
s = sin^{-1}(\frac{W\omega}{v})
$$
という式が得られます。この式を利用することで、目標とする速度と角速度でコースを旋回したいときに、目標とすべきステアリング角度を計算出来ることになります。ただし、3番目の式は速度が0のときにはゼロ割になってしまうので、コードに実装する際は注意が必要です。  
またこの時、ステアリング角度$s$が十分に小さいと仮定すると、上式の$sin(s)$は$sin(s)=s$と近似できるので、2番目の式を変形して次の式を得ることができます。  
$$
k = \frac{s}{W}
$$
そして、この式における曲率$k$とステアリング角度$s$は時系列で変化するものと考えると、それぞれを微分した次の式が得られます。  
$$
\dot{k} = \frac{\dot{s}}{W}
$$
この式における$\dot{s}$はステアリング速度、$\dot{k}$は曲率変化量となります。車両のスペックとしてステアリングを切れる角度や速度には限界があるので、それを考慮してコースの曲率やその変化量を調整する際にこの式が利用できます。  

#### 角速度と速度、ステアリング角度の関係
ステアリング角度と角速度の関係式を変形すると、  
$$
\omega = \frac{v sin(s)}{W}
$$
という式が得られます。この式を利用することで、車両がある速度、あるステアリング角度でコースを旋回したときに、どの程度の角速度で方位が変化するかを理論的に計算することができます。  

### 理論式
ここまでに説明してきた円運動に関する知識を踏まえて、円運動モデルの理論式を導出します。円運動モデルとは下図のように、ある時刻$t$から次の時刻$t+1$の間に移動する車両の動きを、直線運動ではなく円運動として近似するものです。  
![](/images/circular_motion.png)  
ここではまず、車両は一定の旋回半径で回転するものとし、その際の旋回中心位置を$(x_c, y_c)$とします。そして、座標系のX軸を基準に車両が向いている方位角を$\theta_t$とすると、車両位置と旋回中心位置を結んだ直線の向きと車両の方位角の向きが成す角は直角となることから、車両位置と旋回中心位置を結んだ直線と座標系X軸の成す角は$\theta_t-90[deg]$となります。  
以上より、旋回中心位置$(x_c, y_c)$は、  
$$
x_c = x_t - R cos(\theta_t - 90) \\
y_c = y_t - R sin(\theta_t - 90)
$$
とできます。ここで加法定理を用いると$\theta_t-90[deg]$の$sin, cos$成分は、  
$$
cos(\theta_t - 90) = sin\theta_t \\
sin(\theta_t - 90) = -cos\theta_t
$$
となるので先程の旋回中心を求める式は、  
$$
x_c = x_t - R sin\theta_t \\
y_c = y_t + R cos\theta_t
$$
と変形できます。  
次に、車両の移動後の時刻$t+1$における位置$(x_{t+1}, y_{t+1})$は、  
$$
x_{t+1} = x_c + R cos(\theta_{t+1} - 90) \\
y_{t+1} = y_c + R sin(\theta_{t+1} - 90)
$$
となります。ここで、車両が時刻$t$に旋回するときの角速度を$\omega_t$とすると、時刻$t+1$における車両の方位角$\theta_{t+1}$は、  
$$
\theta_{t+1} = \theta_t + \omega_t dt
$$
となります。そして先程説明した加法定理の考え方を考慮すると、上の位置$(x_{t+1}, y_{t+1})$を計算する式は、  
$$
x_{t+1} = x_c + R sin(\theta_t + \omega dt) \\
y_{t+1} = y_c - R cos(\theta_t + \omega dt)
$$
と変形できます。最後に、先程導出した旋回中心$(x_c, y_c)$の計算式と、角速度の計算で説明した$v=R\omega$の式を利用すると上の式は、  
$$
x_{t+1} = x_t - \frac{v_t}{\omega_t}(sin\theta_t - sin(\theta_t+\omega_t dt)) \\
y_{t+1} = y_t + \frac{v_t}{\omega_t}(cos\theta_t - cos(\theta_t+\omega_t dt))
$$
と変形できます。この計算式を利用することで、時刻$t$での位置$(x_t, y_t)$と速度$v_t$、角速度$\omega_t$が分かれば、回転運動時の時刻$t+1$での車両位置が計算できるということになります。  

### Pythonでの実装
上記の理論式を[こちらのPythonコード](/motion_model/circular_motion/circular_motion_model.py)に実装しています。該当するのは下記の部分です。  
```python
def calculate_state(self, x_m, y_m, yaw_deg, speed_ms, yaw_rate_ds):
        """
        速度[m/s]と角速度[deg/s]から車両の位置(x, y)と方位(yaw)を計算する関数
        x_m, y_m, yaw_deg: 1時刻前のx, y座標、方位yaw
        speed_ms: その時刻での速度[m/s]
        yaw_rate_ds: その時刻での角速度[deg/s]
        """

        # 入力
        self.speed_ms = speed_ms
        self.yaw_rate_ds = yaw_rate_ds

        # 旋回半径を計算
        turning_radius_m = speed_ms / np.deg2rad(yaw_rate_ds)

        # 円運動モデルに従って位置と方位を計算
        yaw_deg_next = yaw_deg + yaw_rate_ds * self.interval_sec
        x_m_next = x_m - turning_radius_m * (sin(np.deg2rad(yaw_deg)) - sin(np.deg2rad(yaw_deg_next)))
        y_m_next = y_m + turning_radius_m * (cos(np.deg2rad(yaw_deg)) - cos(np.deg2rad(yaw_deg_next)))
        
        # 速度と角速度からステアリング角度を計算
        # 速度が0になると0割りになるので注意
        steer_rad = asin(self.wheel_base_m * np.deg2rad(yaw_rate_ds)/speed_ms)
        
        return x_m_next, y_m_next, yaw_deg_next, np.rad2deg(steer_rad)
```
このコードを実行すると、直線運動モデルのコードと同様に、車両の位置と方位を計算するシミュレーションが表示されます。  

### 直線運動モデルとの比較
最後に、既に説明した直線運動モデルとの比較をしてみました。[こちらのコード](/motion_model/circular_motion/compare_linear_circular.py)を実行すると、直線運動モデル(青)と円運動モデル(赤)の計算シミュレーションが表示されます。  
まずは刻み時間を50msに設定した場合ですが、若干のずれはあれど両者に大きな違いは見られません。  
![](/images/compare_linear_circular_dt50ms.png)  
次は刻み時間を500msにした場合です。ここでは特に旋回時の違いが大きくなるのが分かります。    
![](/images/compare_linear_circular_dt500ms.png)  

## 四輪モデル
車両の運動モデルとしてまず取り上げられるのは、こちらのような四輪モデルです。  
車両のダイナミクスを考える際は、このような2次元平面の力学、運動学を考えるのが一般的です。  
![](/images/four_wheels_model.png)  

この図の中で定義されている各変数は下記のようになります。  
* $L_f$, $L_r$: 車両の重心位置から前後輪それぞれまでの距離  
* $L$($L_f$+$L_r$): ホイールベース(前後輪間の距離)  
* $d$: トレッド(左右のタイヤ間の距離)
* $V_{fL}$, $V_{fR}$, $V_{rL}$, $V_{rR}$: 前後左右の各タイヤの速度ベクトル  
* $V_b$: 車両の重心位置の速度ベクトル
* $\delta_{fL}$, $\delta_{fR}$: 左右前輪のそれぞれのステアリング舵角
* $\beta_{fL}$, $\beta_{fR}$, $\beta_{rL}$, $\beta_{rR}$: 前後左右の各タイヤのすべり角
* $\beta$: 車両全体のすべり角
* $\dot{\phi}$: 車両方位の角速度
* $CF$: 旋回時に車両にかかる遠心力

このように、前後左右の4つのタイヤにはそれぞれ別々の速度ベクトルやすべり角が生じると考えるのが、四輪モデルの特徴です。

## 二輪モデル
四輪モデルは車両のより細かい動きを表現できる反面、それを実データから解析してモデルとして構築するのが難しいというデメリットもあります。そこで、前後それぞれの左右のタイヤの速度ベクトルやすべり角は同一になると考えることで、モデルをシンプルにするという方法があります。それがこちらの二輪モデルです。  
![](/images/two_wheels_model.png)  

上記の考え方により、左右別々にあったタイヤは一つだとみなすことになり、その形状からBicycle Modelとも呼ばれます。これに伴い、モデルの中で扱う変数の数もかなり少なくなります。  
* $L_f$, $L_r$: 車両の重心位置から前後輪それぞれまでの距離  
* $L$($L_f$+$L_r$): ホイールベース(前後輪間の距離)  
* $V_{r}$, $V_{r}$: 前後のタイヤの速度ベクトル  
* $V_b$: 車両の重心位置の速度ベクトル
* $\delta$: 前輪のそれぞれのステアリング舵角
* $\beta_{f}$, $\beta_{r}$: 前後各タイヤのすべり角
* $\beta$: 車両全体のすべり角
* $\dot{\phi}$: 車両方位の角速度
* $CF$: 旋回時に車両にかかる遠心力

